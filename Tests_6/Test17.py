"""
Друзья друзей
Теория шести рукопожатий — социологическая теория, согласно которой любые два человека на Земле разделены не более, 
чем пятью уровнями общих знакомых (и, соответственно, шестью уровнями связей). Формальная математическая формулировка 
теории: диаметр графа знакомств не превышает 6. Мы не станем так сильно углубляться в дружественные связи и пока нам 
хватит только двух уровней. Напишите программу, которая по списку дружественных пар для каждого человека определяет 
список «друзей 2-го уровня».

Формат ввода
В каждой строке записывается два имени.
Окончанием ввода служит пустая строка.

Формат вывода
Выведите список всех людей и их «друзей 2-го уровня» в формате «Человек: Друг1, Друг2, ...».
Список людей и друзей в каждой строке требуется вывести в алфавитном порядке без повторений.

Ввод:
Иванов Петров
Иванов Сергеев
Васильев Петров
Сергеев Яковлев
Петров Кириллов
Петров Яковлев

Вывод:
Васильев: Иванов, Кириллов, Яковлев
Иванов: Васильев, Кириллов, Яковлев
Кириллов: Васильев, Иванов, Яковлев
Петров: Сергеев
Сергеев: Петров
Яковлев: Васильев, Иванов, Кириллов

Решение: Создаем пустой словарь. Запускаем бесконечный цикл, который завершится при вводе пустой строки. Каждую введенную строку
разделяем при помощи split(). Ключом будет являться первая фамилия, значением - вторая ([0] и [1] соответственно). В случае
если ключа еще нет в словаре - записываем его и присваиваем ему значение второй фамилии, при привязке значения используем 
множество для того, чтобы были только неповторяющиеся элементы, иначе добавляем к ключу вторую фамилию. 
Меняем значение и ключ местами, теперь ключ - это вторая фамилия, а значение - первая, и запускаем ту же проверку. 
Создаем второй словарь куда запишем все ключи из первого и значения, как пустые множества. 
Проходим по ключам первого словаря. Перебираем все значения текущего ключа. Копируем значение во временную переменную, с 
помощью copy(). Удаляем ключ, если он принадлежит множеству, с помощью discard().
Удаляем все одинаковые элементы для всех множеств ключей с помощью difference_update(). 
В новый словарь записываем неповторяющиеся ключи и присваиваем им значения объединения значений ключей и скопированных значений
первого словаря, тем самым удаляя все совпадения и оставляя только уникальные ключи и уникальные значения. 
Сортируем результирующий словарь в алфавитном порядке. И выводим в необходимом виде ключи и значения словаря. 
"""

string = input()
friendship = dict()

while string != '': 
    secondname = string.split(' ')
    if secondname[0] not in friendship.keys():
        friendship[secondname[0]] = {secondname[1]}
    else:
        friendship[secondname[0]].add(secondname[1])
    if secondname[1] not in friendship.keys():
        friendship[secondname[1]] = {secondname[0]}
    else:
        friendship[secondname[1]].add(secondname[0])
    string = input()

friend_result = {key: set() for key in friendship.keys()}
for i in friendship.keys():
    for j in friendship[i]:
        temp = friendship[j].copy()
        temp.discard(i)
        temp.difference_update(friendship[i])
        friend_result[i] = friend_result[i].union(temp)
        
sort_res = sorted(friend_result.items(), key=lambda secondname: secondname[0])
for i in sort_res:
    print(f"{i[0]}: {', '.join(sorted(i[1]))}")

