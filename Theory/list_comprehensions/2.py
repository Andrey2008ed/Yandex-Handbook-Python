"""
Списочные выражения можно применять не только для списков. Напишем программу, которая сгенерирует для некоторой 
строки список кодов символов этой строки из таблицы кодировки:
"""
text = "Строка символов"
codes = [ord(symbol) for symbol in text]
print(codes)
# Вывод программы:

# [1057, 1090, 1088, 1086, 1082, 1072, 32, 1089, 1080, 1084, 1074, 1086, 1083, 1086, 1074]

"""
Покажем применение списочных выражений для обработки словарей. Напишем программу, которая из словаря пар 
"страна: список официальных языков" выберет список стран, у которых более одного официального языка.
"""
countries = {"Россия": ["русский"],
             "Беларусь": ["белорусский", "русский"],
             "Бельгия": ["немецкий", "французский", "нидерландский"],
             "Вьетнам": ["вьетнамский"]}
multiple_lang = [country for (country, lang) in countries.items() if len(lang) > 1]
print(multiple_lang)
# Вывод программы:

# ['Беларусь', 'Бельгия']

"""
Если говорить более подробно, то списочное выражение может возвращать не только список, но и итератор . 
То есть можно не сохранять сразу все значения списочного выражения, а получать их, 
например, в процессе прохода в цикле по итератору. Для этого вместо квадратных скобок укажем круглые. 
Вернём в первом примере не список, а итератор:
"""
numbers = (int(input()) for i in range(5))
print(numbers)
# Вывод программы:

# <generator object <genexpr> at 0x00000266CEA0CAC0>
"""
Программа не ожидала ввода данных, а вывела сразу информацию о переменной numbers. Так произошло, потому что мы 
нигде в программе не использовали значения итератора, а следовательно и не понадобилось их вводить. 
Для получения значений итератора мы можем брать их по одному в цикле или преобразовать итератор в коллекцию 
(например, список) и записать в эту коллекцию сразу все элементы.

Давайте проверим, сколько памяти будет занимать итератор и соответствующий ему список. Для этого воспользуемся функцией 
getsizeof() стандартного модуля sys. Эта функция возвращает размер занимаемой объектом памяти в байтах. Итератор создадим 
с помощью известной нам стандартной функции range().
"""
from sys import getsizeof

# Создаём итератор из одного миллиона целых чисел
numbers_iter = (i for i in range(10 ** 6))
# Выводим количество байт, занятых итератором
print(f"Итератор занимает {getsizeof(numbers_iter)} байт.")
# Создаём список
numbers_list = list(range(10 ** 6))
# Выводим количество байт, занятых списком
print(f"Список занимает {getsizeof(numbers_list)} байт.")
# Вывод программы:

# Итератор занимает 112 байт.
# Список занимает 8000056 байт.
"""
Так размер памяти, занимаемой итератором, существенно меньше, чем у списка. Это связано с тем, что итератор всегда 
хранит только одно текущее значение и может вернуть следующее значение, когда это требуется в программе.

Давайте также сравним скорость работы итератора и списка. В первой программе объединим строки итератора с помощью 
метода join(). Во второй -- сделаем то же самое, но для списка. Сами значения сгенерируем с помощью стандартной 
функции range(). Выведем для обоих вариантов суммарное затраченное на 10 циклов время в секундах с точностью 1 мс.
"""
from timeit import timeit

print(round(timeit(s = '; '.join(str(x) for x in range(10 ** 7)), number=10), 3))
print(round(timeit(s = '; '.join([str(x) for x in list(range(10 ** 7))]), number=10), 3))
# Вывод программы (зависит от ресурсов системы):

# 22.914
# 25.576
"""
Из результата видно, что итератор работает быстрее, чем список, при условии обработки большого количества элементов.
"""