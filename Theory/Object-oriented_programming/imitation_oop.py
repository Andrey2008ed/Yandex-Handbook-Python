"""
Объектная модель Python. Классы, поля и методы
Прежде чем приступить к теории, давайте решим следующую задачу.

Напишем программу, которая будет моделировать объекты класса "автомобиль". При моделировании необходимо 
определить степень детализации объектов, которая зависит от действий, выполняемых этими объектами.

 - Пусть все автомобили имеют разный цвет.
 - Двигатель можно запустить, если в баке есть топливо.
 - Двигатель можно заглушить.
 - На автомобиле можно отправиться в путь на N километров при соблюдении следующих условий: двигатель запущен и 
 запас топлива в баке и средний расход позволяют проехать этот путь.
 - После поездки запас топлива уменьшается в соответствии со средним расходом.
 - Автомобиль можно заправить до полного бака в любой момент времени.

Выделим важные для нашей программы свойства объектов класса: цвет, средний расход топлива, объём топливного бака, 
запас топлива, общий пробег.

Определим, какие действия может выполнять объект: запустить двигатель, проехать N километров, остановить 
двигатель, заправить автомобиль. Пока наши знания позволяют использовать в качестве объекта в программе словарь.

Попробуем описать объекты этого класса с помощью коллекций и функций:
"""

def create_car(color, consumption, tank_volume, mileage=0): # Функция создания автомобиля
    return {
        "color": color, # присваиваем цвет
        "consumption": consumption, # присваиваем средний расход топлива
        "tank_volume": tank_volume, # присваиваем объем бака с топливом
        "reserve": tank_volume, # присваиваем резервный объем бака с топливом
        "mileage": mileage, # присваиваем пробег
        "engine_on": False # присваиваем булево значение для двигателя (включен / выключен) - выключен
    }


def start_engine(car): # Функция запуска двигателя
    if not car["engine_on"] and car["reserve"] > 0: # Если двигатель НЕ включен и резервное топливо больше 0
        car["engine_on"] = True # то переключаем булево значение в True (включая двигатель)
        return "Двигатель запущен." # выдаем информацию о том, что теперь двигатель включен
    return "Двигатель уже был запущен." # иначе выдаем, что двигатель уже был включен


def stop_engine(car): # Функция остановки двигателя
    if car["engine_on"]: # Если двигатель включен
        car["engine_on"] = False # выключаем
        return "Двигатель остановлен." # выдаем информацию о том, что теперь двигатель выключен
    return "Двигатель уже был остановлен."


def drive(car, distance): # Функция вождения
    if not car["engine_on"]: # Если двигатель НЕ включен
        return "Двигатель не запущен." # выдаем информацию о том, что двигатель не запущен
    if car["reserve"] / car["consumption"] * 100 < distance: # Если резерв топлива / резерв бака * 100 < чем дистанция
        return "Малый запас топлива." # выдаем ошибку 
    car["mileage"] += distance # Иначе - пробег += дистанция
    car["reserve"] -= distance / 100 * car["consumption"] # а резерв топлива уменьшаем по формуле (d / 100 * полный бак)
    return f"Проехали {distance} км. Остаток топлива: {car['reserve']} л." # выдаем информацию о том, сколько проехали


def refuel(car): # Функция заполнения бака "на полную"
    car["reserve"] = car["tank_volume"] # резервному топливу присваиваем полный бак


def get_mileage(car): # Функция получения информации о пробеге
    return f"Пробег {car['mileage']} км." # выдаем информацию о пробеге


def get_reserve(car): # Функция получения информации о текущем топливе
    return f"Запас топлива {car['reserve']} л."


car_1 = create_car(color="black", consumption=10, tank_volume=55) # Создаем машину с помощью функции. 
# В качестве аргументов передаем цвет, средний расход топлива и максимальную вместимость топлива в баке

print(start_engine(car_1))
print(drive(car_1, 100))
print(drive(car_1, 100))
print(drive(car_1, 100))
print(drive(car_1, 300))
print(get_mileage(car_1))
print(get_reserve(car_1))
print(stop_engine(car_1))
print(drive(car_1, 100))

"""
Мы описали все действия над объектом с помощью функций. Такой подход в программировании называется процедурным 
и долго время был популярным. Он позволяет эффективно решать простые задачи. Однако при усложнении задачи и 
появлении новых объектов процедурный подход приводит к дублированию и ухудшению читаемости кода.
"""
