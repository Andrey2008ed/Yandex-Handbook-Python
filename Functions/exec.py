# Позволяет динамически выполнить блок кода Python.

# 1. Синтаксис:
#   exec(object, globals=None, locals=None, closure=None)

# 2. Параметры:
#   object - строка кода, либо объект кода,
#   globals - словарь глобального пространства, относительно которого следует исполнить код,
#   locals - объект-отображение (например dict), локальное пространство, в котором следует исполнить код.
#   closure=None - определяет замыкание - кортеж переменных (добавлен в Python 3.11).

# 3. Возвращаемое значение:
#   None.

# 4. Описание:
# Функция exec() поддерживает динамическое выполнение кода Python и принимает большие блоки кода, 
# в отличие от eval(). Передаваемый функции код должен быть либо строкой, либо объектом кода, например 
# сгенерированный функцией compile().
# Если это строка, то строка анализируется как набор операторов Python, который затем выполняется 
# (если не возникает синтаксическая ошибка).
# Если это объект кода, он просто выполняется.
# Во всех случаях ожидается, что исполняемый код будет допустимым для ввода в файл.

# 5. Возвращаемое значение - None.

# Во всех случаях, если globals и locals опущены, то код выполняется в текущей области видимости. 
# Если указываются глобальные переменные, это должен быть словарь (а не подкласс словаря), который 
# будет использоваться как для глобальных, так и для локальных переменных. Если передаются локальные 
# переменные, то locals может быть любым объектом отображения (словарным объектом).
# Помните, что на уровне модуля глобальные и локальные переменные — это один и тот же словарь. 
# Если exec получает два отдельных объекта в качестве глобального и локального, код будет выполняться так, 
# как если бы он был встроен в определение класса.

# Внимание:

# Помните, что инструкции nonlocal, return и yield не могут быть использованы вне определений функций, даже 
# в контексте кода, переданного в exec().

# Помните, что на уровне модуля globals и locals - один и тот же словарь. Если exec() получает два отдельных
#  объекта globals и locals, то код будет исполнен, как если бы он был расположен в объявлении класса.

# Аргумент closure определяет замыкание - кортеж переменных. 
# Это допустимо только в том случае, если объект является кодовым объектом, содержащим свободные переменные. 
# Длина кортежа должна точно соответствовать количеству свободных переменных, на которые ссылается объект кода.
# Изменено в Python 3.11: Добавлен параметр closure.

# Примеры динамического выполнения блока кода.
x = 'name = "John"\nprint(name)'
exec(x)
# John

y = 'print("5 + 10 =", (5+10))'
exec(y)
# 5 + 10 = 15

prog = 'for x in range(9):\n    res = x*x\n    print(res)'
exec(prog)
# 0
# 1
# 4
# 9
# 16
# 25
# 36
# 49
# 64

exec("print('Hey!')") 
# Hey! 

exec("print(6+4)") 
# 10

from math import * 
def squareNo(a): return a*a 
#global And local parameters 
exec('print(pow(4,3))', {"squareit": squareNo, "print": print}) 
# 64

exec("print(dir())")
# ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', 
# '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 
# 'degrees', 'dist', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 
# 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt', 'lcm', 'ldexp', 'lgamma', 'log', 'log10', 
# 'log1p', 'log2', 'modf', 'name', 'nan', 'nextafter', 'perm', 'pi', 'pow', 'prod', 'prog', 'radians', 'remainder', 'res', 
# 'sin', 'sinh', 'sqrt', 'squareNo', 'tan', 'tanh', 'tau', 'trunc', 'ulp', 'x', 'y']

"""
Между методами eval() и exec() есть два основных различия, хотя они выполняют почти одинаковую работу. 
eval() может выполнять только одно выражение, тогда как exec() может использоваться для 
выполнения динамически созданного оператора или программы, которая может включать циклы, операторы if-else , 
определения функций и class , eval() возвращает значение после выполнения определенного выражения, тогда как exec() 
в основном ничего не возвращает и просто игнорирует значение.
"""
